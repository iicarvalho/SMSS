package ssmsProject;

import protocols.ProtocolModel;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.Hashtable;

public class ProtocolSSMS extends ProtocolModel {

    private short origem = 0;
    private short destino = 0;
    private byte algoritmo;
    private byte padding;
    private byte modo;
    private SecureSuite secureSuite;
    private byte[] iv;
    private String mensagem;
    private String chavePadrao = "chave 1 de teste";
    private String codigoErro = "0";
    public static final HashMap<String,Byte> tipoCodigoErro = new HashMap<String,Byte>();
    {
        // Tipos de mensagem com código de erro = 0
        tipoCodigoErro.put("00", (byte) 0b00000000);
        tipoCodigoErro.put("10", (byte) 0b00010000);
        tipoCodigoErro.put("20", (byte) 0b00100000);
        tipoCodigoErro.put("30", (byte) 0b00110000);
        tipoCodigoErro.put("40", (byte) 0b01000000);
        // Tipos de mensagem com código de erro = 1
        tipoCodigoErro.put("01", (byte) 0b00000001);
        tipoCodigoErro.put("11", (byte) 0b00010001);
        tipoCodigoErro.put("21", (byte) 0b00100001);
        tipoCodigoErro.put("31", (byte) 0b00110001);
        tipoCodigoErro.put("41", (byte) 0b01000001);
        // Tipos de mensagem com código de erro = 2
        tipoCodigoErro.put("02", (byte) 0b00000010);
        tipoCodigoErro.put("12", (byte) 0b00010010);
        tipoCodigoErro.put("22", (byte) 0b00100010);
        tipoCodigoErro.put("32", (byte) 0b00110010);
        tipoCodigoErro.put("42", (byte) 0b01000010);
        // Tipos de mensagem com código de erro = 3
        tipoCodigoErro.put("03", (byte) 0b00000011);
        tipoCodigoErro.put("13", (byte) 0b00010011);
        tipoCodigoErro.put("23", (byte) 0b00100011);
        tipoCodigoErro.put("33", (byte) 0b00110011);
        tipoCodigoErro.put("43", (byte) 0b01000011);
        // Tipos de mensagem com código de erro = 4
        tipoCodigoErro.put("04", (byte) 0b00000100);
        tipoCodigoErro.put("14", (byte) 0b00010100);
        tipoCodigoErro.put("24", (byte) 0b00100100);
        tipoCodigoErro.put("34", (byte) 0b00110100);
        tipoCodigoErro.put("44", (byte) 0b01000100);
        // Tipos de mensagem com código de erro = 5
        tipoCodigoErro.put("05", (byte) 0b00000101);
        tipoCodigoErro.put("15", (byte) 0b00010101);
        tipoCodigoErro.put("25", (byte) 0b00100101);
        tipoCodigoErro.put("35", (byte) 0b00110101);
        tipoCodigoErro.put("45", (byte) 0b01000101);
        // Tipos de mensagem com código de erro = 6
        tipoCodigoErro.put("06", (byte) 0b00000110);
        tipoCodigoErro.put("16", (byte) 0b00010110);
        tipoCodigoErro.put("26", (byte) 0b00100110);
        tipoCodigoErro.put("36", (byte) 0b00110110);
        tipoCodigoErro.put("46", (byte) 0b01000110);
    };

    ProtocolSSMS(int mode) {
        super(mode, 4);
        secureSuite = new SecureSuite((int)algoritmo, (int)modo, (int)padding);
    }

    protected byte[] nextMessage() {
        byte[] msg = null;
        switch (this.step) {
            case 0:
                //First message, generated by the CLIENT
                msg = this.genParReq();
                System.out.println("Primeira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 1:
                //Second message, genereted by the SERVER
                msg = this.genParConf();
                System.out.println("Segunda Msg sent...");
                //Util.viewHex(msg);
                break;
            case 2:
                //Third message, generated by the CLIENT
                msg = this.genDadosMsg();
                System.out.println("Terceira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 3:
                //Forth message, generated by the SERVER
                msg = this.genConf();
                System.out.println("Quarta Msg sent...");
                //Util.viewHex(msg);
                break;

        }
        return msg;
    }

    @Override
    public int getHeaderLenght () {
        int ret = 0;
        // Precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload para leitura pelo RunProtocol
        //System.out.println("STEP: " + this.getStep());
        switch (this.getStep()) {
            case 0: ret = 7;break; // mensagem par_req
            case 1: ret = 17;break; // mensagem par_conf
            case 2: ret = 3;break; // mensagem dados
            case 3: ret = 1;break; // mensagem de conf
        }
        return ret;
    }

    /* Informa ao RunProtocol qual o tamanho do payload.
    *  Neste protocolo, o tamanho é zero para as duas primeiras mensagens
    *  e é informado pelo header na terceira mensagem */
    @Override
    public int getPayloadLenght ( byte[] header){
        int ret = 0;
        // precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload

        switch (this.getStep()) {
            case 0: ret = 0;break;
            case 1: ret = 0;break;
            case 2:
                byte[] tamanhoMensagem = new byte[2];
                System.arraycopy(header, 1, tamanhoMensagem, 0, 2);
                ret = convertByteArrayToInt(tamanhoMensagem);
                //System.out.println("Header: "+header[1]);
                break;
            case 3: ret = 0;break;
        }
        return ret;
    }

    protected boolean verifyMessage(byte[] receivedMsg) throws Exception {
        boolean ret = false;
        switch (this.step) {
            case 0:
                //Verify First message, performed by the SERVER
                ret = this.verifyParReq(receivedMsg);
                System.out.println("Primeira Msg ... " + ret);
                break;
            case 1:
                //Verify Second message, performed by the CLIENT
                ret = this.verifyParConf(receivedMsg);
                System.out.println("Segunda Msg ... " + ret);
                break;
            case 2:
                //Verify Third message, performed by the SERVER
                ret = this.verifyData(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
            case 3:
                //Verify Forth message, performed by the CLIENT
                ret = this.verifyConf(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
        }

        return ret;
    }

    private boolean verifyData(byte[] receivedMsg) throws Exception {

        // Ler o tipo e o codigo de erro do cabeçalho (1 byte)
        int[] tipo_codigo;
        tipo_codigo = convertBytetoTwoInts(receivedMsg[0]);

        // Verifica campo do código de erro
        if (tipo_codigo[1] == 0) { // não houve erro, armazena IV
            System.out.println("Mensagem criptografada pelo cliente...");
        } else {
            verifyError(tipo_codigo[1]); // imprime mensagem de erro e gera exception
        }

        // Verifica tipo da mensagem
        if (!verifyMsgType(tipo_codigo[0], 2)) { // tipo da mensagem diferente do esperado
            this.codigoErro = "4";
            return false;
        }


        // Le o tamanho da mensagem
        byte [] tamanho = new byte[2];
        System.arraycopy(receivedMsg, 1, tamanho, 0, 2);
        int msgSize = convertByteArrayToInt(tamanho);
        System.out.println("Tamanho da mensagem criptografada recebida no Server: " + msgSize);

        // Le o campo com os dados (mensagem criptografada)
        byte[] encryptMsg = new byte[msgSize];
        System.arraycopy(receivedMsg, 3, encryptMsg, 0, msgSize);

        // Descriptografa a mensagem
        byte[] decryptMsg = decrypt(this.chavePadrao, encryptMsg, secureSuite.toString(), secureSuite.getTextAlg(), this.iv);
        if (decryptMsg == null) {
            this.codigoErro = "2";
            System.out.println("Erro na execução da descriptografia");
        }

        String mensagemDescripto  = new String(decryptMsg, StandardCharsets.UTF_8);
        System.out.println("Mensagem DESCRIPTOGRAFADA no SERVER: " + mensagemDescripto);


        return true; // retornar receiveMsg
    }

    private boolean verifyConf(byte[] receivedMsg) throws Exception {
        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);

        verifyMsgType(tipo_codErro[0], 4);

        if (tipo_codErro[1] == 0) {
            System.out.println("Dados recebidos com sucesso.");
        } else {
            verifyError(tipo_codErro[1]);
        }

        // Verifica tipo da mensagem
        if (!verifyMsgType(tipo_codErro[0], 4)) { // tipo da mensagem diferente do esperado
            this.codigoErro = "4";
            return false;
        }

        return true;
    }

    private boolean verifyMsgType(int type, int correctType) {
        if (type != correctType)
            System.out.println("O tipo recebido foi " + type + ", mas o tipo esperado era " + correctType);
        return type == correctType;
    }

    /* Método para verificar a primeira mensagem recebida pelo SERVER (par_req) */
    private boolean verifyParReq(byte[] receivedMsg) throws Exception {
        // 1a mensagem sempre correta
        boolean ret = true;

        // atualiza o estado das informações recebidas
        byte alg_padding = receivedMsg[5];

        int[] camposAlgPadding = convertBytetoTwoInts(alg_padding);
        this.modo = receivedMsg[6];
        System.out.println("VALOR DO MODO" + this.modo);

        secureSuite.setAlg(camposAlgPadding[0]); // armazena algoritmo escolhido
        secureSuite.setMode((int)this.modo); // armazena modo escolhido
        secureSuite.setPad(camposAlgPadding[1]); // armazena padding escolhido

        int[] tipo_reservado = convertBytetoTwoInts(receivedMsg[0]);

        if (!verifyMsgType(tipo_reservado[0], 0)) { // tipo da mensagem diferente do esperado
            this.codigoErro = "4";
            ret = false;
        }

        return ret;
    }

    private boolean verifyParConf(byte[] receivedMsg) throws Exception {
        boolean ret = true;

        // Ler o tipo e o codigo de erro do cabeçalho (1 byte)
        int[] tipo_codigo = new int[2];
        tipo_codigo = convertBytetoTwoInts(receivedMsg[0]);

        if (tipo_codigo[1] == 0) { // não houve erro, armazena IV
            System.out.println("Armazenando IV");
            iv = new byte[16];
            System.out.println("iv :" + iv);
            System.arraycopy(receivedMsg, 1, iv, 0, 16);
        } else {
            verifyError(tipo_codigo[1]); // imprime mensagem de erro e gera exception
        }

        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);
        if(!verifyMsgType(tipo_codErro[0], 1)) { // tipo da mensagem diferente do esperado
            this.codigoErro = "4";
            ret = false;
        }


        return ret; // retornar receiveMsg
    }

    private byte[] genParReq() {
        secureSuite.setPad(this.padding);
        secureSuite.setAlg(this.algoritmo);
        secureSuite.setMode(this.modo);
        System.out.println("Executando genParReq");
        /* ORIGEM E DESTINO */
        /* Os valores de origem e destino possuem tamanho de 2 bytes,
         *  por isso, precisam ser alocados em um array de bytes */
        ByteBuffer origemByte = ByteBuffer.allocate(2);
        origemByte.putShort(origem);
        byte[] origemArray = origemByte.array();
        System.out.println("Buffer de origem ok");
        ByteBuffer destinoByte = ByteBuffer.allocate(2);
        destinoByte.putShort(destino);
        System.out.println("Buffer de destino ok");
        byte[] destinoArray = destinoByte.array();

        /** TIPO **/
        /* Os primeiros 4 bits são destinados para definir o tipo da mensagem
         *  que, neste caso sempre será 0 */
        byte tipo_reservado = 0b00000000;

        /* ALGORITMO E PADDING */
        /* Define o valor do byte de acordo com as combinações de algoritmo e padding
        *  O valor do algoritmo está nos primeiros 4 bits
        *  O valor do padding está nos útimos 4 bits */
        byte algoritmo_padding = 0;
        switch (algoritmo) {
            case 0:
                if (padding == 0) {
                    algoritmo_padding = 0b00000000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00000001;
                }
                break;
            case 1:
                if (padding == 0) {
                    algoritmo_padding = 0b00010000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00010001;
                }
                break;
            case 2:
                if (padding == 0) {
                    algoritmo_padding = 0b00100000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00100001;
                }
                break;
            case 3:
                if (padding == 0) {
                    algoritmo_padding = 0b00110000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00110001;
                }
                break;
            case 4:
                if (padding == 0) {
                    algoritmo_padding = 0b01000000;
                } else if (padding == 1){
                    algoritmo_padding = 0b01000001;
                }
                break;
            case 5:
                if (padding == 0) {
                    algoritmo_padding = 0b01010000;
                } else if (padding == 1){
                    algoritmo_padding = 0b01010001;
                }
                break;
            default:
                System.out.println("Erro na geração da mensagem 1 (par_req)." +
                        "O valor digitado para escolha do algortimo é inválido. " +
                        "Escolha um algortimo válido (valores de 0 a 5).");
        }

        byte[] msg = new byte[7]; // a primeira mensagem possui 7 bytes
        msg[0] = tipo_reservado;
        System.arraycopy(origemArray, 0, msg, 1, origemArray.length); // copia o valor da origem na posição msg[1]
        System.arraycopy(destinoArray, 0, msg, origemArray.length + 1, destinoArray.length); // copia o valor do destino na proxima posicao livre de msg[]
        msg[origemArray.length+1+destinoArray.length] = algoritmo_padding;
        msg[origemArray.length+1+destinoArray.length+1] = modo;

        return msg;
    }

    private byte[] genParConf() {
        byte[] parConf = new byte[17];
        byte tipo_erro = getTypeErrorFieldByte("1" + codigoErro); // tipo = 1 e codigo = 0

        System.out.println("Pegando informaçoes do secureSuite");

        // Le as informacoes de algoritmo, modo e padding que estao salvas na classe SecureSuite
        // de acordo com o solicitado pelo CLIENT
        int algoritmo = secureSuite.getAlg();
        int modo = secureSuite.getMode();
        int padding = secureSuite.getPad();
        System.out.println("MODO:" + modo);
        if (secureSuite.algMap.containsKey(algoritmo) && secureSuite.modeMap.containsKey(modo) &&
                secureSuite.padMap.containsKey(padding) ) {
            System.out.println("Valor do algoritmo:" + algoritmo);
            switch (algoritmo) {
                case 0: // aes 128
                case 1: // aes 192
                case 2: // aes 256
                    System.out.println("IvGenerator com block size = 16");
                    this.iv = ivGenerator(16);
                    break;
                case 3: // des
                case 4: // 3des
                case 5: // 3des-ede3
                    System.out.println("IvGenerator com block size = 8");
                    this.iv = ivGenerator(8);
                    break;
                default:
                    this.codigoErro = "1";
                    tipo_erro = getTypeErrorFieldByte("1" + codigoErro); // tipo = 1 e codigo de erro = 1
                    System.out.println("O algoritmo escolhido não é suportado.");
            }
        } else {
            this.codigoErro = "1";
            tipo_erro = getTypeErrorFieldByte("1" + codigoErro); // tipo = 1 e codigo de erro = 1
            System.out.println("Os parâmetros de criptografia escolhidos não são suportados.");
        }
        parConf[0] = tipo_erro;
        System.arraycopy(iv, 0, parConf, 1, 16); // coloca o IV na mensagem a ser enviada
        return parConf;
    }

    private byte[] genDadosMsg() {

        byte tipo_codErro = getTypeErrorFieldByte("2" + codigoErro); // tipo = 2 e codigo de erro

        // Criptografa mensagem
        String strCipher = secureSuite.toString();
        String alg = secureSuite.getTextAlg();
        byte[] mensagemBytes = this.mensagem.getBytes(StandardCharsets.UTF_8);
        
        byte[] mensagemCripto = encrypt(chavePadrao, mensagemBytes, strCipher, alg, iv); // mensagem criptografada

        // Define o vetor que irá no campo 'tamanho' da mensagem enviada
        ByteBuffer tamanhoByte = ByteBuffer.allocate(2);
        tamanhoByte.putShort((short) mensagemCripto.length);
        byte[] tamanhoByteArray = tamanhoByte.array();

        // Constroi mensagem de dados (tipo, codErro, tamanho e mensagem)
        byte[] dados = new byte[3+mensagemCripto.length];
        dados[0] = tipo_codErro;
        System.arraycopy(tamanhoByteArray, 0, dados, 1, tamanhoByteArray.length); // passa o campo tamanho

        System.arraycopy(mensagemCripto, 0, dados, 3, mensagemCripto.length); // passa o campo de dados

        return dados;
    }

    private byte[] genConf() {
        byte[] conf = new byte[1];
        conf[0] = getTypeErrorFieldByte("4" + codigoErro);

        return conf;
    }

    /* Conjunto de métodos SET chamados pelo CLIENT antes que o protocolo seja executado */
    public void setOrigem(short origem){
        this.origem = origem;
    }

    public void setDestino(short destino){
        this.destino = destino;
    }

    public void setAlgoritmo(byte algoritmo){
        this.algoritmo = algoritmo;
    }

    public void setPadding(byte padding){
        this.padding = padding;
    }

    public void setModo(byte modo){
        this.modo = modo;
    }

    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }

    private int convertByteArrayToInt(byte[] intBytes){
        System.out.println("Int Bytes valor:" + intBytes);
        return ByteBuffer.wrap(intBytes).getShort();
    }

    /* Método recebe 1 byte do cabeçalho (dois campos com 4 bits),
     faz a leitura bit a bit e converte os dois campos em inteiro
     Retorna o primeiro e o segundo campos do cabeçalho na primeira e
     segunda posições do vetor field1_field2 respectivamente */
    private int convertBitStringToInt(String tipo){
        int mult = 8;
        int charValue;
        int campoValue= 0;
        char c;
        for (int i=0; i< tipo.length(); i++){
            c = tipo.charAt(i);
            charValue = c - '0';
            campoValue += (charValue * mult);
            mult /= 2;
        }
        return campoValue;
    }
    private int[] convertBytetoTwoInts(byte header) {
        String headerString = String.format("%8s", Integer.toBinaryString(header & 0xFF)).replace(' ', '0');

        int field1 = convertBitStringToInt (headerString.substring(0, 4));
        int field2 = convertBitStringToInt (headerString.substring(4, 8));

        int [] array = {field1, field2};

        return array;

    }

    private byte[] ivGenerator(int tamanho) {
        byte[] iv = new byte[tamanho];
        SecureRandom srandom = new SecureRandom();
        srandom.nextBytes(iv);
        return iv;
    }

    private void verifyError(int codigoErro) {
        String errorMsg = null;
        switch (codigoErro) {
            case 1:
                errorMsg = "Parâmetros não suportados";
                break;
            case 2:
                errorMsg = "Erro interno não definido";
                break;
            case 3:
                errorMsg = "Não há chave compartilhada";
                break;
            case 4:
                errorMsg = "TIpo de mensagem inesperado";
                break;
            case 5:
                errorMsg = "Vetor de inicialização nulo";
                break;
            case 6:
                errorMsg = "Falha nos blocos de dados cifrados";
                break;
        }
        throw new RuntimeException(errorMsg);
    }

    private byte getTypeErrorFieldByte(String fieldsValue) {
        return tipoCodigoErro.get(fieldsValue);
    }

    /* Métodos de criptografia */
    public static byte[] encrypt(String chave, byte[] value, String strCipher, String alg, byte[] iv) {
        try {
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec skeySpec = new SecretKeySpec(chave.getBytes(StandardCharsets.UTF_8), alg);
            System.out.println("String Cipher:" + strCipher);
            Cipher cipher = Cipher.getInstance(strCipher);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);

            return cipher.doFinal(value);
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    public static byte[] decrypt(String chave, byte[] value, String strCipher, String alg, byte[] iv) {
        try {
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec skeySpec = new SecretKeySpec(chave.getBytes(StandardCharsets.UTF_8), alg);

            Cipher cipher = Cipher.getInstance(strCipher);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec);

            return cipher.doFinal(value);
        } catch(Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}


