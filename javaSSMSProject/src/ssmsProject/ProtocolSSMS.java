package ssmsProject;

import protocols.ProtocolModel;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.HashMap;

public class ProtocolSSMS extends ProtocolModel {

    private short origem=0;
    private short destino=0;
    private byte algoritmo;
    private byte padding;
    private byte modo;
    private boolean errorMsg = false;
    private SecureSuite secureSuite;
    private byte[] iv;
    private String mensagem;
    private String chavePadrao = "chave 1 de teste";

    ProtocolSSMS(int mode) {
        super(mode, 4);
        secureSuite = new SecureSuite((int)algoritmo, (int)modo, (int)padding);
    }

    protected byte[] nextMessage() {
        byte[] msg = null;
        switch (this.step) {
            case 0:
                //First message, generated by the CLIENT
                msg = this.genParReq();
                System.out.println("Primeira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 1:
                //Second message, genereted by the SERVER
                msg = this.genParConf();
                System.out.println("Segunda Msg sent...");
                //Util.viewHex(msg);
                break;
            case 2:
                //Third message, generated by the CLIENT
                msg = this.genDadosMsg();
                System.out.println("Terceira Msg sent...");
                //Util.viewHex(msg);
                break;
            case 3:
                //Forth message, generated by the SERVER
                msg = this.genConf();
                System.out.println("Quarta Msg sent...");
                //Util.viewHex(msg);
                break;

        }
        return msg;
    }

    @Override
    public int getHeaderLenght () {
        int ret = 0;
        // Precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload para leitura pelo RunProtocol
        //System.out.println("STEP: " + this.getStep());
        switch (this.getStep()) {
            case 0: ret = 7;break; // mensagem par_req
            case 1: ret = 17;break; // mensagem par_conf
            case 2: ret = 3;break; // mensagem dados
            case 3: ret = 1;break; // mensagem de conf
        }
        return ret;
    }

    /* Informa ao RunProtocol qual o tamanho do payload.
    *  Neste protocolo, o tamanho é zero para as duas primeiras mensagens
    *  e é informado pelo header na terceira mensagem */
    @Override
    public int getPayloadLenght ( byte[] header){
        int ret = 0;
        // precisa reconhecer o tipo da mensagem e saber o tamanho
        // do cabeçalho e payload

        switch (this.getStep()) {
            case 0: ret = 0;break;
            case 1: ret = 0;break;
            case 2:
                byte[] tamanhoMensagem = new byte[2];
                System.arraycopy(header, 1, tamanhoMensagem, 0, 2);
                ret = convertByteArrayToInt(tamanhoMensagem);
                //System.out.println("Header: "+header[1]);
                break;
            case 3: ret = 0;break;
        }
        return ret;
    }

    protected boolean verifyMessage(byte[] receivedMsg) throws Exception {
        boolean ret = false;
        switch (this.step) {
            case 0:
                //Verify First message, performed by the SERVER
                ret = this.verifyParReq(receivedMsg);
                System.out.println("Primeira Msg ... " + ret);
                break;
            case 1:
                //Verify Second message, performed by the CLIENT
                ret = this.verifyParConf(receivedMsg);
                System.out.println("Segunda Msg ... " + ret);
                break;
            case 2:
                //Verify Third message, performed by the SERVER
                ret = this.verifyData(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
            case 3:
                //Verify Forth message, performed by the CLIENT
                ret = this.verifyConf(receivedMsg);
                System.out.println("Terceira Msg ... " + ret);
                break;
        }

        return ret;
    }

    private boolean verifyData(byte[] receivedMsg) throws Exception {

        //tam msg
        //dados

        // Ler o tipo e o codigo de erro do cabeçalho (1 byte)
        int[] tipo_codigo = new int[2];
        tipo_codigo = convertBytetoTwoInts(receivedMsg[0]);

        if (tipo_codigo[1] == 0) { // não houve erro, armazena IV
            System.out.println("Mensagem criptografada pelo cliente...");
        } else {
            verifyError(tipo_codigo[1]); // imprime mensagem de erro e gera exception
        }

        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);

        verifyMsgType(tipo_codErro[0], 2);

        byte [] tamanho = new byte[2];

        System.arraycopy(receivedMsg, 1, tamanho, 0, 2);

        //int  = convertByteArrayToInt(tamanho);

        return true; // retornar receiveMsg

    }

    private boolean verifyConf(byte[] receivedMsg) throws Exception {
        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);

        verifyMsgType(tipo_codErro[0], 4);

        if (tipo_codErro[1] == 0) {
            System.out.println("Dados recebidos com sucesso.");
        } else {
            verifyError(tipo_codErro[1]);
        }

        return true;
    }

    private void verifyMsgType(int type, int correctType) throws Exception {
        if(type != correctType) {
            throw new Exception("O tipo recebido foi " + type + ", mas o tipo esperado era " + correctType);
        }
    }

    /* Método para verificar a primeira mensagem recebida pelo SERVER (par_req) */
    private boolean verifyParReq(byte[] receivedMsg) throws Exception {
        // 1a mensagem sempre correta
        boolean ret = true;
        // atualização do status do protocolo, para o caso de enviar mensagem de erro
        this.errorMsg = false;
        // atualiza o estado das informações recebidas
        byte alg_padding = receivedMsg[5];

        int[] camposAlgPadding = convertBytetoTwoInts(alg_padding);
        this.modo = receivedMsg[6];
        System.out.println("VALOR DO MODO" + this.modo);

        secureSuite.setAlg(camposAlgPadding[0]);
        secureSuite.setMode((int)this.modo);
        secureSuite.setPad(camposAlgPadding[1]);

        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);
        verifyMsgType(tipo_codErro[0], 0);

        return ret;
    }

    private boolean verifyParConf(byte[] receivedMsg) throws Exception {
        boolean ret = true;

        // Ler o tipo e o codigo de erro do cabeçalho (1 byte)
        int[] tipo_codigo = new int[2];
        tipo_codigo = convertBytetoTwoInts(receivedMsg[0]);

        if (tipo_codigo[1] == 0) { // não houve erro, armazena IV
            System.out.println("Armazenando IV");
            iv = new byte[16];
            System.out.println("iv :" + iv);
            System.arraycopy(receivedMsg, 1, iv, 0, 16);
        } else {
            verifyError(tipo_codigo[1]); // imprime mensagem de erro e gera exception
        }

        int[] tipo_codErro = convertBytetoTwoInts(receivedMsg[0]);
        verifyMsgType(tipo_codErro[0], 1);

        return ret; // retornar receiveMsg
    }

    private byte[] genParReq() {
        secureSuite.setPad(this.padding);
        secureSuite.setAlg(this.algoritmo);
        secureSuite.setMode(this.modo);
        System.out.println("Executando genParReq");
        /* ORIGEM E DESTINO */
        /* Os valores de origem e destino possuem tamanho de 2 bytes,
         *  por isso, precisam ser alocados em um array de bytes */
        ByteBuffer origemByte = ByteBuffer.allocate(2);
        origemByte.putShort(origem);
        byte[] origemArray = origemByte.array();
        System.out.println("Buffer de origem ok");
        ByteBuffer destinoByte = ByteBuffer.allocate(2);
        destinoByte.putShort(destino);
        System.out.println("Buffer de destino ok");
        byte[] destinoArray = destinoByte.array();

        /** TIPO **/
        /* Os primeiros 4 bits são destinados para definir o tipo da mensagem
         *  que, neste caso sempre será 0 */
        byte tipo_reservado = 0b00000000;

        /* ALGORITMO E PADDING */
        /* Define o valor do byte de acordo com as combinações de algoritmo e padding
        *  O valor do algoritmo está nos primeiros 4 bits
        *  O valor do padding está nos útimos 4 bits */
        byte algoritmo_padding = 0;
        switch (algoritmo) {
            case 0:
                if (padding == 0) {
                    algoritmo_padding = 0b00000000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00000001;
                }
                break;
            case 1:
                if (padding == 0) {
                    algoritmo_padding = 0b00010000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00010001;
                }
                break;
            case 2:
                if (padding == 0) {
                    algoritmo_padding = 0b00100000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00100001;
                }
                break;
            case 3:
                if (padding == 0) {
                    algoritmo_padding = 0b00110000;
                } else if (padding == 1){
                    algoritmo_padding = 0b00110001;
                }
                break;
            case 4:
                if (padding == 0) {
                    algoritmo_padding = 0b01000000;
                } else if (padding == 1){
                    algoritmo_padding = 0b01000001;
                }
                break;
            case 5:
                if (padding == 0) {
                    algoritmo_padding = 0b01010000;
                } else if (padding == 1){
                    algoritmo_padding = 0b01010001;
                }
                break;
            default:
                System.out.println("Erro na geração da mensagem 1 (par_req)." +
                        "O valor digitado para escolha do algortimo é inválido. " +
                        "Escolha um algortimo válido (valores de 0 a 5).");
        }

        byte[] msg = new byte[7]; // a primeira mensagem possui 7 bytes
        msg[0] = tipo_reservado;
        System.arraycopy(origemArray, 0, msg, 1, origemArray.length); // copia o valor da origem na posição msg[1]
        System.arraycopy(destinoArray, 0, msg, origemArray.length + 1, destinoArray.length); // copia o valor do destino na proxima posicao livre de msg[]
        msg[origemArray.length+1+destinoArray.length] = algoritmo_padding;
        msg[origemArray.length+1+destinoArray.length+1] = modo;

        return msg;
    }

    private byte[] genParConf() {
        byte[] parConf = new byte[17];
        byte tipo_erro = 0b00010000;
        // Verificar qual o algoritmo, modo e padding solicitados pelo cliente
        // Se o SERVER suportar essa solicitacao:
            // cria IV
            // armazena tipo + IV no vetor de byte parConf
        // Senão:
            // informar codigo de erro
        System.out.println("Pegando informaçoes do secureSuite");

        int algoritmo = secureSuite.getAlg();
        int modo = secureSuite.getMode();
        int padding = secureSuite.getPad();
        System.out.println("MODO:" + modo);
        if (secureSuite.algMap.containsKey(algoritmo) && secureSuite.modeMap.containsKey(modo) &&
                secureSuite.padMap.containsKey(padding) ) {
            System.out.println("Valor do algoritmo:" + algoritmo);
            switch (algoritmo) {
                case 0: // aes 128
                case 1: // aes 192
                case 2: // aes 256
                    System.out.println("IvGenerator com block size = 16");
                    this.iv = ivGenerator(16);
                    break;
                case 3: // des
                case 4: // 3des
                case 5: // 3des-ede3
                    System.out.println("IvGenerator com block size = 8");
                    this.iv = ivGenerator(8);
                    break;
                default:
                    System.out.println("Case incorreto");
            }
        } else {
            tipo_erro = 0b00010001; // codigo de erro = 1
            System.out.println("Erro de parâmetros em genParConf");
        }
        parConf[0] = tipo_erro;
        System.arraycopy(iv, 0, parConf, 1, 16);
        return parConf;
    }

    private byte[] genDadosMsg() {

        byte tipo_codErro = 0b00100000; // tipo = 2 e codigo de erro


        ByteBuffer tamanhoByte = ByteBuffer.allocate(4);
        tamanhoByte.putInt(origem);
        byte[] tamanhoByteArray = tamanhoByte.array();
        System.out.println("Tamnho da mensagem ok");

        // Criptografa mensagem
        String strCipher = secureSuite.toString();
        String alg = secureSuite.getTextAlg();
        String encryptMsg = encrypt(chavePadrao, mensagem, strCipher, alg, iv);
        int tamanho = encryptMsg.length(); // tamanho
        byte[] msg = encryptMsg.getBytes(); // mensagem criptografada em bytes

        // Constroi mensagem de dados (tipo, codErro, tamanho e mensagem)
        byte[] dados = new byte[3+tamanho];
        dados[0] = tipo_codErro;
        System.arraycopy(tamanhoByteArray, 0, dados, 1, 2); // passa o campo tamanho
        System.out.println(msg);
        System.out.println(msg.length);
        System.arraycopy(msg, 0, dados, 3, msg.length); // passa o campo de dados
        System.out.println("MODO (genDadosmsg:" + this.modo);
        return dados;
    }

    private byte[] genConf() {
        /*
         * ESPECIFICAÇÃO DADOS
         * TIPO = 4
         * CÓDIGO DE ERRO = de 0 a 6
         */

        /* Pseudo-código */
        // Declarar os valores especificados

        // Copiar os valores acima para o vetor de bytes conf
        byte[] conf = new byte[1];
        return conf;
    }

    /* Conjunto de métodos SET chamados pelo CLIENT antes que o protocolo seja executado */
    public void setOrigem(short origem){
        this.origem = origem;
    }

    public void setDestino(short destino){
        this.destino = destino;
    }

    public void setAlgoritmo(byte algoritmo){
        this.algoritmo = algoritmo;
    }

    public void setPadding(byte padding){
        this.padding = padding;
    }

    public void setModo(byte modo){
        this.modo = modo;
    }

    public void setMensagem(String mensagem) {
        this.mensagem = mensagem;
    }

    private int convertByteArrayToInt(byte[] intBytes){
        System.out.println("Int Bytes valor:" + intBytes);
        return ByteBuffer.wrap(intBytes).getShort();
    }

    /* Método recebe 1 byte do cabeçalho (dois campos com 4 bits),
     faz a leitura bit a bit e converte os dois campos em inteiro
     Retorna o primeiro e o segundo campos do cabeçalho na primeira e
     segunda posições do vetor field1_field2 respectivamente */
    private int convertBitStringToInt(String tipo){
        int mult = 8;
        int charValue;
        int campoValue= 0;
        char c;
        for (int i=0; i< tipo.length(); i++){
            c = tipo.charAt(i);
            charValue = c - '0';
            campoValue += (charValue * mult);
            mult /= 2;
        }
        return campoValue;
    }
    private int[] convertBytetoTwoInts(byte header) {
        String headerString = String.format("%8s", Integer.toBinaryString(header & 0xFF)).replace(' ', '0');

        int field1 = convertBitStringToInt (headerString.substring(0, 4));
        int field2 = convertBitStringToInt (headerString.substring(4, 8));

        int [] array = {field1, field2};

        return array;

    }

    private byte[] ivGenerator(int tamanho) {
        byte[] iv = new byte[tamanho];
        SecureRandom srandom = new SecureRandom();
        srandom.nextBytes(iv);
        return iv;
    }

    private void verifyError(int codigoErro) {
        String errorMsg = null;
        switch (codigoErro) {
            case 1:
                errorMsg = "Parâmetros não suportados";
                break;
            case 2:
                errorMsg = "Erro interno não definido";
                break;
            case 3:
                errorMsg = "Não há chave compartilhada";
                break;
            case 4:
                errorMsg = "TIpo de mensagem inesperado";
                break;
            case 5:
                errorMsg = "Vetor de inicialização nulo";
                break;
            case 6:
                errorMsg = "Falha nos blocos de dados cifrados";
                break;
        }
        throw new RuntimeException(errorMsg);
    }

    /* Métodos de criptografia */
    public static String encrypt(String chave, String value, String strCipher, String alg, byte[] iv) {
        try {
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec skeySpec = new SecretKeySpec(chave.getBytes(StandardCharsets.UTF_8), alg);
            System.out.println("String Cipher:" + strCipher);
            Cipher cipher = Cipher.getInstance(strCipher);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println("Encrypt:" + Base64.getEncoder().encodeToString(encrypted));
            return Base64.getEncoder().encodeToString(encrypted);
        } catch(Exception e) {
            e.printStackTrace();
        }

        return null;
    }
}

// throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException


